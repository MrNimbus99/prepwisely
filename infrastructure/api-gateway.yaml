AWSTemplateFormatVersion: '2010-09-09'
Description: 'PrepWisely API Gateway and Lambda Functions'

Resources:
  # Lambda Execution Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: PrepWisely-Lambda-Role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - Fn::ImportValue: PrepWisely-UsersTableArn
                  - Fn::ImportValue: PrepWisely-QuestionsTableArn
                  - Fn::ImportValue: PrepWisely-UserProgressTableArn
                  - !Sub 
                    - '${TableArn}/index/*'
                    - TableArn: 
                        Fn::ImportValue: PrepWisely-QuestionsTableArn

  # API Gateway
  PrepWiselyApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: PrepWisely-API
      Description: PrepWisely REST API
      EndpointConfiguration:
        Types:
          - REGIONAL

  # API Gateway Authorizer (Cognito)
  ApiAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      Name: CognitoAuthorizer
      Type: COGNITO_USER_POOLS
      IdentitySource: method.request.header.Authorization
      RestApiId: !Ref PrepWiselyApi
      ProviderARNs:
        - !Sub 
          - 'arn:aws:cognito-idp:${AWS::Region}:${AWS::AccountId}:userpool/${UserPoolId}'
          - UserPoolId:
              Fn::ImportValue: prepwisely-cognito-stack-UserPoolId

  # Lambda Functions
  GetUserFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-GetUser
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE: 
            Fn::ImportValue: PrepWisely-UsersTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, GetCommand } = require('@aws-sdk/lib-dynamodb');
          
          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const userId = event.pathParameters.userId;
              const result = await docClient.send(new GetCommand({
                TableName: process.env.USERS_TABLE,
                Key: { userId }
              }));
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify(result.Item || {})
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to get user' })
              };
            }
          };

  UpdateUserFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-UpdateUser
      Runtime: nodejs18.x
      Handler: index.updateUser
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE:
            Fn::ImportValue: PrepWisely-UsersTable
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.updateUser = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const userId = event.pathParameters.userId;
              const data = JSON.parse(event.body);
              await dynamodb.put({
                TableName: process.env.USERS_TABLE,
                Item: {
                  userId,
                  ...data,
                  updatedAt: new Date().toISOString()
                }
              }).promise();
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ success: true })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to update user' })
              };
            }
          };

  GetQuestionsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-GetQuestions
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          QUESTIONS_TABLE:
            Fn::ImportValue: PrepWisely-QuestionsTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, QueryCommand } = require('@aws-sdk/lib-dynamodb');
          
          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const { certId, quizId } = event.pathParameters;
              const result = await docClient.send(new QueryCommand({
                TableName: process.env.QUESTIONS_TABLE,
                IndexName: 'certId-quizId-index',
                KeyConditionExpression: 'certId = :certId AND quizId = :quizId',
                ExpressionAttributeValues: {
                  ':certId': certId,
                  ':quizId': quizId
                }
              }));
              
              const items = result.Items || [];
              items.sort((a, b) => (a.order || 0) - (b.order || 0));
              
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify(items)
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to get questions' })
              };
            }
          };

  DeleteQuestionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-DeleteQuestion
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          QUESTIONS_TABLE:
            Fn::ImportValue: PrepWisely-QuestionsTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, DeleteCommand } = require('@aws-sdk/lib-dynamodb');
          
          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const { questionId } = event.pathParameters;
              
              await docClient.send(new DeleteCommand({
                TableName: process.env.QUESTIONS_TABLE,
                Key: { questionId }
              }));
              
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ success: true })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to delete question' })
              };
            }
          };

  UpdateQuestionOrderFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-UpdateQuestionOrder
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          QUESTIONS_TABLE:
            Fn::ImportValue: PrepWisely-QuestionsTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, UpdateCommand } = require('@aws-sdk/lib-dynamodb');
          
          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const { questionId } = event.pathParameters;
              const data = typeof event.body === 'string' ? JSON.parse(event.body) : event;
              
              await docClient.send(new UpdateCommand({
                TableName: process.env.QUESTIONS_TABLE,
                Key: { questionId },
                UpdateExpression: 'SET #order = :order',
                ExpressionAttributeNames: {
                  '#order': 'order'
                },
                ExpressionAttributeValues: {
                  ':order': data.order
                }
              }));
              
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ success: true })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to update order' })
              };
            }
          };

  CreateQuestionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-CreateQuestion
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          QUESTIONS_TABLE:
            Fn::ImportValue: PrepWisely-QuestionsTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, PutCommand, QueryCommand } = require('@aws-sdk/lib-dynamodb');
          const { randomUUID } = require('crypto');
          
          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const data = typeof event.body === 'string' ? JSON.parse(event.body) : event;
              const questionId = randomUUID();
              
              const existingQuestions = await docClient.send(new QueryCommand({
                TableName: process.env.QUESTIONS_TABLE,
                IndexName: 'certId-quizId-index',
                KeyConditionExpression: 'certId = :certId AND quizId = :quizId',
                ExpressionAttributeValues: {
                  ':certId': data.certId,
                  ':quizId': data.quizId
                }
              }));
              
              const nextOrder = (existingQuestions.Items || []).length;
              
              await docClient.send(new PutCommand({
                TableName: process.env.QUESTIONS_TABLE,
                Item: {
                  questionId,
                  certId: data.certId,
                  quizId: data.quizId,
                  domain: data.domain,
                  status: data.status,
                  questionText: data.questionText,
                  options: data.options,
                  correctAnswer: data.correctAnswer,
                  explanation: data.explanation,
                  order: nextOrder,
                  createdAt: data.createdAt
                }
              }));
              
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ success: true, questionId })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to create question' })
              };
            }
          };

  GetQuestionCountFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-GetQuestionCount
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          QUESTIONS_TABLE:
            Fn::ImportValue: PrepWisely-QuestionsTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, QueryCommand } = require('@aws-sdk/lib-dynamodb');
          
          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const { certId, quizId } = event.pathParameters;
              const result = await docClient.send(new QueryCommand({
                TableName: process.env.QUESTIONS_TABLE,
                IndexName: 'certId-quizId-index',
                KeyConditionExpression: 'certId = :certId AND quizId = :quizId',
                Select: 'COUNT',
                ExpressionAttributeValues: {
                  ':certId': certId,
                  ':quizId': quizId
                }
              }));
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ count: result.Count || 0 })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ count: 0 })
              };
            }
          };

  SaveProgressFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-SaveProgress
      Runtime: nodejs18.x
      Handler: index.saveProgress
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          PROGRESS_TABLE:
            Fn::ImportValue: PrepWisely-UserProgressTable
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.saveProgress = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const userId = event.pathParameters.userId;
              const { certId, quizId, score, passed } = JSON.parse(event.body);
              await dynamodb.put({
                TableName: process.env.PROGRESS_TABLE,
                Item: {
                  userId,
                  certQuizId: `${certId}#${quizId}`,
                  certId,
                  quizId,
                  score,
                  passed,
                  completedAt: new Date().toISOString()
                }
              }).promise();
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ success: true })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to save progress' })
              };
            }
          };

  GetProgressFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrepWisely-GetProgress
      Runtime: nodejs18.x
      Handler: index.getProgress
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          PROGRESS_TABLE:
            Fn::ImportValue: PrepWisely-UserProgressTable
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.getProgress = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Content-Type': 'application/json'
            };
            try {
              const userId = event.pathParameters.userId;
              const certId = event.queryStringParameters?.certId;
              const params = {
                TableName: process.env.PROGRESS_TABLE,
                KeyConditionExpression: 'userId = :userId',
                ExpressionAttributeValues: { ':userId': userId }
              };
              if (certId) {
                params.KeyConditionExpression += ' AND begins_with(certQuizId, :certId)';
                params.ExpressionAttributeValues[':certId'] = certId;
              }
              const result = await dynamodb.query(params).promise();
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify(result.Items || [])
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: 'Failed to get progress' })
              };
            }
          };

  # API Gateway Resources
  QuestionsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PrepWiselyApi
      ParentId: !GetAtt PrepWiselyApi.RootResourceId
      PathPart: questions

  QuestionsCertResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PrepWiselyApi
      ParentId: !Ref QuestionsResource
      PathPart: '{certId}'

  QuestionsQuizResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PrepWiselyApi
      ParentId: !Ref QuestionsCertResource
      PathPart: '{quizId}'

  # GET /questions/{certId}/{quizId}
  GetQuestionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PrepWiselyApi
      ResourceId: !Ref QuestionsQuizResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetQuestionsFunction.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  GetQuestionsPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetQuestionsFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${PrepWiselyApi}/*/*'

  # POST /questions
  PostQuestionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PrepWiselyApi
      ResourceId: !Ref QuestionsResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateQuestionFunction.Arn}/invocations'

  CreateQuestionPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CreateQuestionFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${PrepWiselyApi}/*/*'

  # API Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - GetQuestionsMethod
      - PostQuestionsMethod
    Properties:
      RestApiId: !Ref PrepWiselyApi
      StageName: prod

Outputs:
  ApiEndpoint:
    Description: API Gateway endpoint URL
    Value: !Sub 'https://${PrepWiselyApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Export:
      Name: PrepWisely-ApiEndpoint
  
  LambdaRoleArn:
    Description: Lambda execution role ARN
    Value: !GetAtt LambdaExecutionRole.Arn
    Export:
      Name: PrepWisely-LambdaRoleArn

